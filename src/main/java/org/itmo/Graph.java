package org.itmo;

import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.stream.Collectors;

class Graph {
  private final int V;
  private final ArrayList<Integer>[] adjList;
  private final int P = Runtime.getRuntime().availableProcessors();
  private final ExecutorService threadPool = Executors.newFixedThreadPool(P);

  Graph(int vertices) {
    this.V = vertices;
    adjList = new ArrayList[vertices];
    for (int i = 0; i < vertices; ++i) {
      adjList[i] = new ArrayList<>();
    }
  }

  void addEdge(int src, int dest) {
    if (!adjList[src].contains(dest)) {
      adjList[src].add(dest);
    }
  }

  int[] parallelBFS(int startVertex) {
    AtomicBoolean[] visited = new AtomicBoolean[V];
    for (int i = 0; i < V; i++) {
      visited[i] = new AtomicBoolean(false);
    }
    List<Integer> frontiers = new ArrayList<>();
    int[] dist = new int[V];

    frontiers.add(startVertex);
    visited[startVertex].set(true);
    dist[startVertex] = 0;
    var chunkSize = (V + P) / P;
    var chunkCount = (int) Math.ceil((double) V / chunkSize);

    while (!frontiers.isEmpty()) {
      int levelSize = frontiers.size();
      CompletableFuture<List<Integer>>[] futures = new CompletableFuture[chunkCount];
      for (int i = 0; i < chunkCount; i++) {
        int from = i * chunkSize;
        int to = Math.min(from + chunkSize, levelSize);
        List<Integer> finalFrontiers = frontiers;
        futures[i] = CompletableFuture.supplyAsync(() -> {
          List<Integer> localFrontiers = new ArrayList<>();
          for (int j = from; j < to; j++) {
            int vertex = finalFrontiers.get(j);
            for (var neighbour : adjList[vertex]) {
              if (visited[neighbour].compareAndSet(false, true)) {
                localFrontiers.add(neighbour);
                dist[neighbour] = dist[vertex] + 1;
              }
            }
          }
          return localFrontiers;
        }, threadPool);
      }
      frontiers = CompletableFuture.allOf(futures)
        .thenApply(unused ->
          Arrays.stream(futures)
            .flatMap(future -> future.join().stream())
            .toList()
        ).join();
    }
    return dist;
  }

  //Generated by ChatGPT
  int[] bfs(int startVertex) {
    boolean[] visited = new boolean[V];
    int[] dist = new int[V];

    LinkedList<Integer> queue = new LinkedList<>();

    visited[startVertex] = true;
    queue.add(startVertex);
    dist[startVertex] = 0;

    while (!queue.isEmpty()) {
      startVertex = queue.poll();

      for (int n : adjList[startVertex]) {
        if (!visited[n]) {
          visited[n] = true;
          dist[n] = dist[startVertex] + 1;
          queue.add(n);
        }
      }
    }

    return dist;
  }

}
