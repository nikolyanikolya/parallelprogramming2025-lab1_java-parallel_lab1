package org.itmo;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.atomic.AtomicBoolean;

class Graph {
  private final int V;
  private final ArrayList<Integer>[] adjList;

  Graph(int vertices) {
    this.V = vertices;
    adjList = new ArrayList[vertices];
    for (int i = 0; i < vertices; ++i) {
      adjList[i] = new ArrayList<>();
    }
  }

  void addEdge(int src, int dest) {
    if (!adjList[src].contains(dest)) {
      adjList[src].add(dest);
    }
  }

  int[] parallelBFS(int startVertex, int P, ExecutorService pool) {
    AtomicBoolean[] visited = new AtomicBoolean[V];
    for (int i = 0; i < V; i++) {
      visited[i] = new AtomicBoolean(false);
    }
    List<Integer> frontiers = List.of(startVertex);
    int[] dist = new int[V];

    visited[startVertex].set(true);
    dist[startVertex] = 0;

    while (!frontiers.isEmpty()) {
      int levelSize = frontiers.size();
      var chunkSize = (levelSize + P) / P;
      var chunkCount = (int) Math.ceil((double) levelSize / chunkSize);
      CompletableFuture<List<Integer>>[] futures = new CompletableFuture[chunkCount];
      for (int i = 0; i < chunkCount; i++) {
        int from = i * chunkSize;
        int to = Math.min(from + chunkSize, levelSize);
        List<Integer> finalFrontiers = frontiers;
        futures[i] = CompletableFuture.supplyAsync(() -> {
          List<Integer> nextLocalFrontiers = new ArrayList<>();
          for (int j = from; j < to; j++) {
            int vertex = finalFrontiers.get(j);
            for (var neighbour : adjList[vertex]) {
              if (visited[neighbour].compareAndSet(false, true)) {
                nextLocalFrontiers.add(neighbour);
                dist[neighbour] = dist[vertex] + 1;
              }
            }
          }
          return nextLocalFrontiers;
        }, pool);
      }
      frontiers = CompletableFuture.allOf(futures)
        .thenApply(unused ->
          Arrays.stream(futures)
            .flatMap(future -> future.join().stream())
            .toList()
        ).join();
    }
    return dist;
  }

  //Generated by ChatGPT
  int[] bfs(int startVertex) {
    boolean[] visited = new boolean[V];
    int[] dist = new int[V];

    LinkedList<Integer> queue = new LinkedList<>();

    visited[startVertex] = true;
    queue.add(startVertex);
    dist[startVertex] = 0;

    while (!queue.isEmpty()) {
      startVertex = queue.poll();

      for (int n : adjList[startVertex]) {
        if (!visited[n]) {
          visited[n] = true;
          dist[n] = dist[startVertex] + 1;
          queue.add(n);
        }
      }
    }

    return dist;
  }

}
