package org.itmo;

import kotlin.ranges.IntRange;

import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import java.util.stream.Stream;

import static java.util.stream.Collectors.toList;

class Graph {
  private final int V;
  private final ArrayList<Integer>[] adjList;
  private final int P = Runtime.getRuntime().availableProcessors();
  private final ExecutorService threadPool = Executors.newFixedThreadPool(P);

  Graph(int vertices) {
    this.V = vertices;
    adjList = new ArrayList[vertices];
    for (int i = 0; i < vertices; ++i) {
      adjList[i] = new ArrayList<>();
    }
  }

  void addEdge(int src, int dest) {
    if (!adjList[src].contains(dest)) {
      adjList[src].add(dest);
    }
  }

  void parallelBFS(int startVertex) {
    AtomicBoolean[] visited = new AtomicBoolean[V];
    for (int i = 0; i < V; i++) {
      visited[i] = new AtomicBoolean(false);
    }
    ConcurrentLinkedQueue<Integer> frontiers = new ConcurrentLinkedQueue<>();

    frontiers.add(startVertex);
    visited[startVertex].set(true);

    while (!frontiers.isEmpty()) {
      int levelSize = frontiers.size();
      CompletableFuture<Void>[] futures = new CompletableFuture[levelSize];
      ConcurrentLinkedQueue<Integer> nextFrontiers = new ConcurrentLinkedQueue<>();
      int i = 0;
      for (int vertex: frontiers) {
        futures[i++] = CompletableFuture.runAsync(() -> {
          for (var neighbour : adjList[vertex]) {
            if (visited[neighbour].compareAndSet(false, true)) {
              nextFrontiers.add(neighbour);
            }
          }
        }, threadPool);
      }
      CompletableFuture.allOf(futures).join();
      frontiers = nextFrontiers;
    }
  }

  //Generated by ChatGPT
  void bfs(int startVertex) {
    boolean[] visited = new boolean[V];

    LinkedList<Integer> queue = new LinkedList<>();

    visited[startVertex] = true;
    queue.add(startVertex);

    while (!queue.isEmpty()) {
      startVertex = queue.poll();

      for (int n : adjList[startVertex]) {
        if (!visited[n]) {
          visited[n] = true;
          queue.add(n);
        }
      }
    }
  }

}
